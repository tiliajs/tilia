// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Dict from "@rescript/core/src/Core__Dict.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var d = {
  c: 0
};

var CoreBug = /* @__PURE__ */Caml_exceptions.create("TiliaCore.CoreBug");

function _connect(param, notify) {
  var root = param[0];
  var observer_sym = Symbol("obs");
  var observer_collector = [];
  var observer = {
    sym: observer_sym,
    notify: notify,
    collector: observer_collector,
    root: root
  };
  root.collecting = observer_collector;
  console.log("CREATE");
  return observer;
}

function _clear(observer) {
  var sym = observer.sym;
  if (observer.root.observers.delete(sym)) {
    d.c = d.c - 1 | 0;
    console.log("CLEAR", d.c);
    observer.collector.forEach(function (param) {
          var key = param[1];
          var observed = param[0];
          var eyes = observed[key];
          if (eyes === undefined) {
            return ;
          }
          var eyes$1 = Caml_option.valFromOption(eyes);
          if (eyes$1.delete(sym) && eyes$1.size === 0) {
            Core__Dict.$$delete(observed, key);
            return ;
          }
          
        });
    return ;
  }
  
}

function _flush(observer) {
  d.c = d.c + 1 | 0;
  console.log("FLUSH", d.c);
  var root = observer.root;
  var sym = observer.sym;
  var c = root.collecting;
  if (c !== undefined && Caml_obj.equal(c, observer.collector)) {
    root.collecting = undefined;
  }
  root.observers.set(sym, observer);
  observer.collector.forEach(function (extra) {
        var key = extra[1];
        var observed = extra[0];
        var eyes = observed[key];
        var eyes$1;
        if (eyes !== undefined) {
          eyes$1 = Caml_option.valFromOption(eyes);
        } else {
          var eyes$2 = new Set();
          observed[key] = eyes$2;
          eyes$1 = eyes$2;
        }
        eyes$1.add(sym);
      });
}

function proxify(root, target) {
  var observed = {};
  return new Proxy(target, {
              set: (function (extra, extra$1, extra$2) {
                  var prev = Reflect.get(extra, extra$1);
                  if (Caml_obj.equal(prev, extra$2)) {
                    return true;
                  }
                  if (!Reflect.set(extra, extra$1, extra$2)) {
                    return false;
                  }
                  var eyes = observed[extra$1];
                  if (eyes !== undefined) {
                    Core__Dict.$$delete(observed, extra$1);
                    Caml_option.valFromOption(eyes).forEach(function (sym) {
                          var observer = root.observers.get(sym);
                          if (observer !== undefined) {
                            _clear(observer);
                            return observer.notify();
                          }
                          throw {
                                RE_EXN_ID: CoreBug,
                                _1: "Observing sym should always be in root.observers.",
                                Error: new Error()
                              };
                        });
                  }
                  return true;
                }),
              get: (function (extra, extra$1) {
                  var c = root.collecting;
                  if (c !== undefined) {
                    c.push([
                          observed,
                          extra$1
                        ]);
                  }
                  return Reflect.get(extra, extra$1);
                })
            });
}

function make(seed) {
  var root = {
    collecting: undefined,
    observers: new Map()
  };
  return [
          root,
          proxify(root, seed)
        ];
}

function observe(t, callback) {
  var p = t[1];
  var notify = function () {
    var o = _connect(t, notify);
    callback(p);
    _flush(o);
  };
  notify();
}

export {
  make ,
  _connect ,
  _flush ,
  _clear ,
  observe ,
}
/* No side effect */
