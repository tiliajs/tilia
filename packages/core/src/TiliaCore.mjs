// Generated by ReScript, PLEASE EDIT WITH CARE


var object = (function(v) {
  return typeof v === 'object' && v !== null;
});

function readonly(o, k) {
  var d = Object.getOwnPropertyDescriptor(o, k);
  if (d === null || d === undefined) {
    return false;
  } else {
    return d.writable === false;
  }
}

var indexKey = (Symbol());

var rootKey = (Symbol());

var metaKey = (Symbol());

function _meta(p) {
  return Reflect.get(p, metaKey);
}

function _connect(p, notify, notifyIfChangedOpt) {
  var notifyIfChanged = notifyIfChangedOpt !== undefined ? notifyIfChangedOpt : true;
  var root = Reflect.get(p, rootKey);
  if (root === null || root === undefined) {
    if (root === null) {
      throw new Error("Observed state is not a tilia proxy.");
    }
    throw new Error("Observed state is not a tilia proxy.");
  } else {
    var observer = {
      state: notifyIfChanged ? "Recording" : "RecordingNoNotify",
      watcher: Symbol(""),
      notify: notify,
      observing: [],
      root: root
    };
    root.observers.set(observer.watcher, observer);
    root.observer = observer;
    return observer;
  }
}

function observeKey(observer, observed, key) {
  var w = observed.get(key);
  var w$1;
  var exit = 0;
  if (w === null || w === undefined) {
    exit = 1;
  } else {
    w$1 = w;
  }
  if (exit === 1) {
    var w$2 = new Set();
    observed.set(key, w$2);
    w$1 = w$2;
  }
  w$1.add(observer.watcher);
  observer.observing.push(w$1);
}

function _clear(observer) {
  var watcher = observer.watcher;
  if (observer.root.observers.delete(watcher)) {
    observer.observing.forEach(function (watchers) {
          watchers.delete(watcher);
        });
  }
  observer.state = "Cleared";
}

function _ready(observer) {
  var state = observer.state;
  var root = observer.root;
  var o = root.observer;
  if (o === null || o === undefined) {
    o === null;
  } else if (o === observer) {
    root.observer = undefined;
  }
  switch (state) {
    case "ShouldNotify" :
        observer.notify();
        observer.state = "Notified";
        return ;
    case "Recording" :
    case "RecordingNoNotify" :
        observer.state = "Ready";
        return ;
    case "Cleared" :
        var watcher = observer.watcher;
        observer.root.observers.set(watcher, observer);
        observer.observing.forEach(function (watchers) {
              watchers.add(watcher);
            });
        observer.state = "Ready";
        return ;
    case "Ready" :
    case "Notified" :
        return ;
    
  }
}

function notify(root, observed, key) {
  var watchers = observed.get(key);
  if (watchers === null || watchers === undefined) {
    return ;
  }
  var removable = {
    contents: true
  };
  Array.from(watchers).forEach(function (watcher) {
        var observer = root.observers.get(watcher);
        if (observer === undefined) {
          return ;
        }
        var match = observer.state;
        switch (match) {
          case "Recording" :
              _clear(observer);
              observer.state = "ShouldNotify";
              return ;
          case "RecordingNoNotify" :
              removable.contents = false;
              return ;
          case "Ready" :
              _clear(observer);
              observer.notify();
              observer.state = "Notified";
              return ;
          default:
            return ;
        }
      });
  if (removable.contents && watchers.size === 0) {
    observed.delete(key);
    return ;
  }
  
}

function proxify(root, _target) {
  while(true) {
    var target = _target;
    var observed = new Map();
    var proxied = new Map();
    var r = Reflect.get(target, rootKey);
    if (r === null || r === undefined) {
      r === null;
    } else {
      if (r === root) {
        return target;
      }
      _target = _meta(target).target;
      continue ;
    }
    return new Proxy(target, {
                set: (function(observed,proxied){
                return function (extra, extra$1, extra$2) {
                  var hadKey = Reflect.has(extra, extra$1);
                  var prev = Reflect.get(extra, extra$1);
                  if (prev === extra$2) {
                    return true;
                  } else if (Reflect.set(extra, extra$1, extra$2)) {
                    if (object(prev)) {
                      proxied.delete(extra$1);
                    }
                    notify(root, observed, extra$1);
                    if (!hadKey) {
                      notify(root, observed, indexKey);
                    }
                    return true;
                  } else {
                    return false;
                  }
                }
                }(observed,proxied)),
                deleteProperty: (function(observed,proxied){
                return function (extra, extra$1) {
                  var res = Reflect.deleteProperty(extra, extra$1);
                  proxied.delete(extra$1);
                  notify(root, observed, extra$1);
                  return res;
                }
                }(observed,proxied)),
                get: (function(target,observed,proxied){
                return function (extra, extra$1) {
                  var isArray = Array.isArray(target);
                  if (extra$1 === rootKey) {
                    return root;
                  }
                  if (extra$1 === metaKey) {
                    return ({root, target, observed, proxied});
                  }
                  var v = Reflect.get(extra, extra$1);
                  var own = Object.hasOwn(extra, extra$1);
                  if (!(v === undefined || own)) {
                    return v;
                  }
                  var o = root.observer;
                  if (o === null || o === undefined) {
                    o === null;
                  } else if (isArray && extra$1 === "length") {
                    observeKey(o, observed, indexKey);
                  } else {
                    observeKey(o, observed, extra$1);
                  }
                  if (!(object(v) && !readonly(extra, extra$1))) {
                    return v;
                  }
                  var p = proxied.get(extra$1);
                  if (!(p === null || p === undefined)) {
                    return p;
                  }
                  p === null;
                  var p$1 = proxify(root, v);
                  proxied.set(extra$1, p$1);
                  return p$1;
                }
                }(target,observed,proxied)),
                ownKeys: (function(observed){
                return function (extra) {
                  var keys = Reflect.ownKeys(extra);
                  var o = root.observer;
                  if (o === null || o === undefined) {
                    o === null;
                  } else {
                    observeKey(o, observed, indexKey);
                  }
                  return keys;
                }
                }(observed))
              });
  };
}

function make(seed) {
  var root = {
    observer: undefined,
    observers: new Map()
  };
  return proxify(root, seed);
}

function observe(p, callback) {
  var notify = function () {
    var o = _connect(p, notify, false);
    callback(p);
    _ready(o);
  };
  notify();
}

export {
  make ,
  observe ,
  _connect ,
  _ready ,
  _clear ,
  _meta ,
}
/* indexKey Not a pure module */
