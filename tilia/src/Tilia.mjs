// Generated by ReScript, PLEASE EDIT WITH CARE


var raise = (function (message) {
  throw new Error(message)
});

var symbol = (function(s) {
  return Symbol.for('tilia:' + s);
});

var indexKey = symbol("indexKey");

var metaKey = symbol("metaKey");

var computeKey = symbol("computeKey");

var ctxKey = symbol("ctx");

function noop() {
  
}

var proxiable = (function(v) {
  if ( typeof v === 'object' && v !== null) {
    const proto = Object.getPrototypeOf(v)
    return proto === Object.prototype || proto === Array.prototype || proto === null
  }
  return false;
});

var compute = (function(v) {
  return typeof v === 'object' && v !== null && v[computeKey] ? v : undefined;
});

function readonly(o, k) {
  var d = Object.getOwnPropertyDescriptor(o, k);
  if (d === null || d === undefined) {
    return false;
  } else {
    return d.writable === false;
  }
}

function _meta(p) {
  return Reflect.get(p, metaKey);
}

function observeKey(observed, key) {
  var w = observed.get(key);
  if (!(w === null || w === undefined)) {
    return w;
  }
  w === null;
  var w$1 = {
    state: "Pristine",
    key: key,
    observed: observed,
    observers: new Set()
  };
  observed.set(key, w$1);
  return w$1;
}

function flush(root) {
  var expired = root.expired;
  if (expired === null || expired === undefined) {
    return ;
  } else {
    return root.flush(function () {
                root.expired = undefined;
                expired.forEach(function (observer) {
                      observer.notify();
                    });
              });
  }
}

function clearObserver(root, observer) {
  observer.observing.forEach(function (watchers) {
        if (watchers.state === "Pristine" && watchers.observers.delete(observer) && watchers.observers.size === 0) {
          watchers.state = "Cleared";
          watchers.observed.delete(watchers.key);
          return ;
        }
        
      });
  var o = root.observer;
  if (o === null || o === undefined || o !== observer) {
    return ;
  } else {
    root.observer = undefined;
    return flush(root);
  }
}

function setReady(root, observer, notifyIfChanged) {
  observer.observing.find(function (w, idx) {
        var match = w.state;
        switch (match) {
          case "Pristine" :
              w.observers.add(observer);
              return false;
          case "Changed" :
              if (notifyIfChanged) {
                clearObserver(root, observer);
                observer.notify();
                return true;
              }
              break;
          case "Cleared" :
              break;
          
        }
        var w$1 = observeKey(w.observed, w.key);
        w$1.observers.add(observer);
        observer.observing[idx] = w$1;
        return false;
      });
  var match = root.observer;
  if (match === null || match === undefined) {
    return ;
  }
  root.observer = undefined;
  flush(root);
}

function notify(root, observed, key) {
  var watchers = observed.get(key);
  if (watchers === null || watchers === undefined) {
    return ;
  }
  observed.delete(key);
  watchers.state = "Changed";
  var expired = root.expired;
  var expired$1;
  var exit = 0;
  if (expired === null || expired === undefined) {
    exit = 1;
  } else {
    expired$1 = expired;
  }
  if (exit === 1) {
    var expired$2 = new Set();
    root.expired = expired$2;
    expired$1 = expired$2;
  }
  watchers.observers.forEach(function (observer) {
        clearObserver(root, observer);
        expired$1.add(observer);
      });
  var match = root.observer;
  if (match === null || match === undefined) {
    return flush(root);
  }
  
}

function set(root, observed, proxied, computes, _fromComputed, target, key, _value) {
  while(true) {
    var value = _value;
    var fromComputed = _fromComputed;
    var o = root.observer;
    if (o === null || o === undefined) {
      o === null;
    } else if (o.immutable) {
      root.observer = undefined;
      raise("Cannot mutate state in an immutable observer");
    }
    var hadKey = Reflect.has(target, key);
    var prev = Reflect.get(target, key);
    var proxiable$1 = proxiable(value);
    var same;
    if (proxiable$1) {
      var m = _meta(value);
      same = m === null || m === undefined ? prev === value : m.target === prev;
    } else {
      same = prev === value;
    }
    if (same) {
      return true;
    }
    if (!Reflect.set(target, key, value)) {
      return false;
    }
    if (proxiable$1) {
      proxied.delete(key);
    }
    var compute$1 = compute(value);
    if (compute$1 === null || compute$1 === undefined) {
      compute$1 === null;
    } else {
      var match = computes.get(key);
      if (match === null || match === undefined) {
        match === null;
      } else {
        var clear = match.clear;
        clear();
        computes.delete(key);
      }
      setupComputed(root, observed, proxied, computes, target, key, compute$1);
      if (!observed.has(key)) {
        return true;
      }
      _value = compute$1.rebuild();
      _fromComputed = true;
      continue ;
    }
    var match$1 = computes.get(key);
    if (match$1 === null || match$1 === undefined) {
      match$1 === null;
    } else if (!fromComputed) {
      root.observer = undefined;
      raise("Cannot mutate a computed value");
    }
    notify(root, observed, key);
    if (!hadKey) {
      notify(root, observed, indexKey);
    }
    return true;
  };
}

function setupComputed(root, observed, proxied, computes, target, key, compute) {
  var lastValue = {
    v: undefined
  };
  var observer = {
    o: undefined
  };
  var callback = compute.rebuild;
  var notify = function () {
    var v = Reflect.get(target, key);
    if (v !== compute) {
      lastValue.v = v;
    }
    if (observed.has(key)) {
      set(root, observed, proxied, computes, true, target, key, rebuild());
    } else {
      Reflect.deleteProperty(proxied, key);
      Reflect.set(target, key, compute);
    }
  };
  var rebuild = function (p) {
    Reflect.set(target, key, lastValue.v);
    var o_observing = [];
    var o = {
      immutable: true,
      notify: notify,
      observing: o_observing
    };
    observer.o = o;
    var previous = root.observer;
    root.observer = o;
    var v = callback(p);
    setReady(root, o, false);
    root.observer = previous;
    return v;
  };
  compute.rebuild = rebuild;
  compute.clear = (function () {
      var o = observer.o;
      if (o === null || o === undefined) {
        return ;
      } else {
        return clearObserver(root, o);
      }
    });
  computes.set(key, compute);
}

function proxify(root, _target) {
  while(true) {
    var target = _target;
    var proxied = new Map();
    var observed = new Map();
    var computes = new Map();
    var m = _meta(target);
    if (m === null || m === undefined) {
      m === null;
    } else {
      if (m.root === root) {
        return m;
      }
      _target = m.target;
      continue ;
    }
    var meta = ({root, target, observed, proxied, computes});
    var isArray = Array.isArray(target);
    var proxy = new Proxy(target, {
          set: (function(proxied,observed,computes){
          return function (extra, extra$1, extra$2) {
            return set(root, observed, proxied, computes, false, extra, extra$1, extra$2);
          }
          }(proxied,observed,computes)),
          deleteProperty: (function(proxied,observed,computes){
          return function (extra, extra$1) {
            var res = Reflect.deleteProperty(extra, extra$1);
            proxied.delete(extra$1);
            var match = computes.get(extra$1);
            if (match === null || match === undefined) {
              match === null;
            } else {
              var clear = match.clear;
              clear();
              computes.delete(extra$1);
            }
            notify(root, observed, extra$1);
            return res;
          }
          }(proxied,observed,computes)),
          get: (function(proxied,observed,computes,isArray){
          return function (extra, extra$1) {
            if (extra$1 === metaKey) {
              return meta;
            }
            var v = Reflect.get(extra, extra$1);
            var own = Object.hasOwn(extra, extra$1);
            if (!(v === undefined || own)) {
              return v;
            }
            var o = root.observer;
            if (o === null || o === undefined) {
              o === null;
            } else if (isArray && extra$1 === "length") {
              var w = observeKey(observed, indexKey);
              o.observing.push(w);
            } else {
              var w$1 = observeKey(observed, extra$1);
              o.observing.push(w$1);
            }
            if (!(proxiable(v) && !readonly(extra, extra$1))) {
              return v;
            }
            var compute$1 = compute(v);
            var exit = 0;
            if (compute$1 === null || compute$1 === undefined) {
              exit = 1;
            } else {
              if (compute$1.clear === noop) {
                setupComputed(root, observed, proxied, computes, extra, extra$1, compute$1);
              }
              var v$1 = compute$1.rebuild();
              Reflect.set(extra, extra$1, v$1);
              if (!(proxiable(v$1) && !readonly(extra, extra$1))) {
                return v$1;
              }
              var m = proxify(root, v$1);
              proxied.set(extra$1, m);
              return m.proxy;
            }
            if (exit === 1) {
              var m$1 = proxied.get(extra$1);
              var exit$1 = 0;
              if (!(m$1 === null || m$1 === undefined)) {
                return m$1.proxy;
              }
              exit$1 = 2;
              if (exit$1 === 2) {
                var m$2 = proxify(root, v);
                proxied.set(extra$1, m$2);
                return m$2.proxy;
              }
              
            }
            
          }
          }(proxied,observed,computes,isArray)),
          ownKeys: (function(observed){
          return function (extra) {
            var keys = Reflect.ownKeys(extra);
            var o = root.observer;
            if (o === null || o === undefined) {
              o === null;
            } else {
              var w = observeKey(observed, indexKey);
              o.observing.push(w);
            }
            return keys;
          }
          }(observed))
        });
    meta.proxy = proxy;
    return meta;
  };
}

function immediateFlush(fn) {
  fn();
}

function makeTilia(root) {
  return function (value) {
    if (!proxiable(value)) {
      raise("connect: value is not an object or array");
    }
    return proxify(root, value).proxy;
  };
}

function makeObserve(root) {
  return function (callback) {
    var notify = function () {
      var observer_observing = [];
      var observer = {
        immutable: false,
        notify: notify,
        observing: observer_observing
      };
      root.observer = observer;
      var o = observer;
      callback();
      setReady(root, o, true);
    };
    notify();
  };
}

function computed(callback) {
  var v = {
    clear: noop,
    rebuild: callback
  };
  Reflect.set(v, computeKey, true);
  return v;
}

function makeSignal(tilia) {
  return function (value) {
    var s = tilia({
          value: value
        });
    var set = function (v) {
      Reflect.set(s, "value", v);
    };
    return [
            s,
            set
          ];
  };
}

function makeStore(signal) {
  return function (init) {
    var match = signal(undefined);
    var set = match[1];
    set(init(set));
    return match[0];
  };
}

function makeObserve_(root) {
  return function (notify, immutable) {
    var observer_observing = [];
    var observer = {
      immutable: immutable,
      notify: notify,
      observing: observer_observing
    };
    root.observer = observer;
    return observer;
  };
}

function makeReady_(root) {
  return function (observer, notifyIfChanged) {
    setReady(root, observer, notifyIfChanged);
  };
}

function connector(tilia, computed, observe, signal, store, _observe, _ready, _clear) {
  return {
    // 
    tilia,
    computed, 
    observe,
    // extra
    signal,
    store,
    // internal
    _observe,
    _ready,
    _clear,
    _meta,
  };
}
;

function make(flushOpt) {
  var flush = flushOpt !== undefined ? flushOpt : immediateFlush;
  var root = {
    observer: undefined,
    expired: undefined,
    flush: flush
  };
  var tilia = makeTilia(root);
  var signal = makeSignal(tilia);
  return connector(tilia, computed, makeObserve(root), signal, makeStore(signal), makeObserve_(root), makeReady_(root), (function (observer) {
                clearObserver(root, observer);
              }), _meta);
}

var ctx = Reflect.get(globalThis, ctxKey);

var _ctx;

var exit = 0;

if (ctx === null || ctx === undefined) {
  exit = 1;
} else {
  _ctx = ctx;
}

if (exit === 1) {
  var ctx$1 = make(immediateFlush);
  Reflect.set(globalThis, ctxKey, ctx$1);
  _ctx = ctx$1;
}

var tilia = _ctx.tilia;

var observe = _ctx.observe;

var signal = _ctx.signal;

var store = _ctx.store;

var _observe = _ctx._observe;

var _ready = _ctx._ready;

var _clear = _ctx._clear;

export {
  make ,
  tilia ,
  computed ,
  observe ,
  signal ,
  store ,
  _observe ,
  _ready ,
  _clear ,
  _meta ,
  _ctx ,
}
/* indexKey Not a pure module */
